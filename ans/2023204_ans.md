# 缺损二叉树

本题虽然看起来很复杂，但是，如果上课认真听讲的话，就能很快做出来。

本题的提示很关键。请看这句话：

> 对本题，可以根据题目要求逐行构造该缺损二叉树。对于当前行，记录所有非缺损点，在下一行依次构造子节点，并排除缺损点，直到构造到目标节点为止。利用构造节点时记录的父亲节点编号，可以从目标节点搜索到回到根节点的路径，将该路径翻转，即可得到所求路径。

我们可以思考一下这棵缺损二叉树的大小。由于题目假定缺损点及目标点数目不超过 $100$ 个，目标节点编号均小于 $2^{32}$。因此，通过简单的数学运算，我们可以知道，这棵缺损二叉树不会超过 $132$ 层。这对于限时 1000ms 的本题来说是一个很大的突破点。我们可以对于每一个目标点，只构建它所在的那条路径，这样并不会消耗许多时间。

二叉树是一个非常美观的数据结构。它有很强的数学性质。我们以完全二叉树为例。假设我们的二叉树的根节点的编号为 $1$，那么，对于任意一个节点 $i$，它的左儿子的编号为 $2i$，它的右儿子的编号为 $2i+1$。这样，假如我们想要从子节点出发，找到它的父节点，那么，我们只需要将它的编号除以 $2$，就可以得到它的父节点的编号。这样，我们就可以从目标节点出发，一直向上找，直到找到根节点为止。这样，我们就可以得到从目标节点到根节点的路径。

这个性质对于缺损二叉树是相通的。下面请看详细说明。

![缺损二叉树](http://oj.ee.tsinghua.edu.cn/media/ckeditor_uploads/2023/11/03/4.png)

我们用例题举例。我们想找到 $15$ 的父节点。于是我们将 $15$ 除以 $2$，得到 $7$。我们发现，$5$ 是一个缺损点， $7$ 不可避免地会受到影响。我们将 $7$ 加一，得到 $8$。继续来看，我们发现 $6$ 也是一个缺损点。 $8$ 再自增 $1$，得到 $9$。我们发现 $9$ 也是一个缺损点。我们再自增 $1$，得到 $10$。我们发现 $10$ 不是一个缺损点。所以，$10$ 就是 $15$ 的父节点。

接下来，我们只要考虑一些特殊情况就可以了。如果一整行都是缺损点会怎样？如果 $1$ 是目标点会怎样？……

另外，注意目标节点编号均小于 $2^{32}$，这是一个很大的数。因此，我们需要用 `unsigned int` 来存储它们。

| #   | 状态     | 时间 | 内存   |
| --- | -------- | ---- | ------ |
| 1   | Accepted | 0 ms | 768 KB |
| 2   | Accepted | 0 ms | 764 KB |
| 3   | Accepted | 0 ms | 760 KB |
| 4   | Accepted | 0 ms | 772 KB |
| 5   | Accepted | 0 ms | 788 KB |
| 6   | Accepted | 0 ms | 760 KB |
| 7   | Accepted | 0 ms | 756 KB |
| 8   | Accepted | 0 ms | 788 KB |
| 9   | Accepted | 0 ms | 756 KB |
| 10  | Accepted | 0 ms | 784 KB |
